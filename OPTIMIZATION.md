# Luludanmaku 长期运行性能优化报告

## 1. 背景与问题分析
在针对高并发弹幕场景（如大型直播间）及长期挂机运行的测试中，原有的弹幕处理机制存在以下性能瓶颈：
- **IPC 通信过频**：每一条弹幕/礼物消息都单独通过 IPC 从主进程发送到渲染进程，导致主进程 CPU 占用过高，且挤占 Electron 的 IPC 通道。
- **渲染线程阻塞**：渲染进程在接收到每条消息时直接触发 React 状态更新（`setState`），在高并发下（如每秒 100+ 条弹幕）会导致 React 频繁执行 Reconciliation（协调）算法，造成 UI 卡顿。
- **内存无限制增长**：原有的列表（特别是礼物和 SC 列表）未做严格的长度限制，长期运行会导致内存持续增长，最终引发 OOM（内存溢出）崩溃。

## 2. 优化方案实施

针对上述问题，我们实施了 "主进程-渲染进程" 双层缓冲策略。

### 2.1 主进程优化：IPC 消息分批 (Main Process Batching)
**位置**: `main/background.ts`

- **原理**：引入消息缓冲区 `messageBuffer` 和定时器。
- **机制**：
  - WebSocket 收到消息后，不再直接调用 `event.reply`，而是推入 `messageBuffer`。
  - 设置 `100ms` 的定时器（Timer）。
  - 每 100ms 检查缓冲区，若有数据，将整个数组一次性打包发送给渲染进程。
- **效果**：IPC 通信频率从 **N 次/秒** 降低为 **10 次/秒**（固定），大幅降低了进程间通信开销。

### 2.2 渲染进程优化：批量渲染与内存保护 (Renderer Process Batching)
**位置**: `renderer/pages/home.jsx`

- **原理**：引入渲染缓冲区 `renderBuffer` (`useRef`) 和 React 批量更新策略。
- **机制**：
  - **接收层**：`msgHandler` 接收到 IPC 传来的数据（可能是单条或数组），直接存入 `renderBuffer.current`，**不触发**任何状态更新。
  - **渲染层**：设置 `200ms` 的定时器（即 5 FPS 的逻辑刷新率）。
  - **批量更新**：定时器回调中，一次性取出缓冲区所有数据，进行解析和分类。
  - **原子化 Commit**：一次性调用 `setDanmuList`、`setScList` 等，React 18（或 Next.js 环境）会自动合并这些 State 更新，减少重渲染次数。
- **内存保护**：
  - 在更新列表时，强制执行 `.slice(0, Limit)` 操作。
  - **普通弹幕**：限制保留最近 **1000** 条。
  - **SC / 礼物**：限制保留最近 **500** 条。

## 3. 性能对比预期

| 指标 | 优化前 | 优化后 |
| :--- | :--- | :--- |
| **IPC 调用频率** | 随弹幕量线性增长 (可达 100+ 次/秒) | 固定 ≤ 10 次/秒 |
| **React 重渲染** | 随弹幕量线性增长 | 固定 ≤ 5 次/秒 |
| **CPU 占用** | 高并发下极高，易假死 | 稳定，大幅降低 |
| **内存占用** | 随时间无限增长 | 稳定在固定区间 |
| **UI 响应度** | 高并发下拖拽窗口卡顿 | 始终保持流畅 |

## 4. 后续建议
- **虚拟滚动 (Virtual Scrolling)**：如果未来需要保留更多历史弹幕（如 > 1000 条），建议引入 `react-window` 或 `react-virtualized` 替换当前的 CSS 溢出滚动，进一步降低 DOM 节点数量带来的内存压力。
- **Canvas 渲染**：对于极致性能需求，可考虑将弹幕列表改为 Canvas 绘制，完全脱离 DOM。

---
*文档生成时间: 2026-01-06*
